# JVM面试总结

# 一：JVM 总览

## 1. JVM架构总览图

<img src="F:\JAVA\JVM\JVM上篇配图\JVM上篇配图\第02章_JVM架构-简图.jpg" alt="第02章_JVM架构-简图" style="zoom:50%;" />




# 二：Java内存模型（运行时数据区）

<img src="F:\JAVA\JVM\JVM上篇配图\JVM上篇配图\第02章_JVM架构-中.jpg" alt="第02章_JVM架构-中" style="zoom: 50%;" />

​	java的内存结构主要针对的是运行时数据区部分，主要包括 线程私有的 虚拟机栈、PC寄存器和本地方法栈  以及线程间共享的堆和方法区，其中每一个JVM对应一个Runtime实例，即一个运行时环境。
## 1. PC 寄存器

定义：用来存储指向下一条指令的地址，也即将要执行的指令代码，由执行引擎读取（当执行Native方法时，PC寄存器为 NULL 值）。

特点：不存在OMM，也不需要GC

存在PC寄存器，且线程私有的原因：JVM是多线程的，当CPU在各个线程间切换时，需要保存现场，当切换回来时，才能继续执行。

## 2. 虚拟机栈
虚拟机栈的图示：
![第05章_栈桢内部结构](F:\JAVA\JVM\JVM上篇配图\JVM上篇配图\第05章_栈桢内部结构.jpg)

1. 定义：

​	Java虚拟机栈，早期也叫做java栈，每个线程私有，内部保存一个个的栈帧，对应着一次java方法的调用，是线程私有的，生命周期与线程一致，主要管理java程序的运行，保存方法的局部变量，部分结果，并参与方法的调用和返回
特点：因为JVM对于java虚拟机栈的操作只有出栈和入栈，执行结束后就会弹出栈，所以不存在垃圾回收问题。但是可能会出现StackOverflowError 和 OutOfMemoryError 两种异常：
​	采用固定大小的java虚拟机栈时，每一个线程的java虚拟机栈的容量在创建时就确定好了，如果线程分配的栈容量超过了虚拟机栈允许的最大容量就会报 StackOverflowError 栈溢出异常；
​	如果Java虚拟机栈的大小可以动态扩展时，并且在尝试扩展的过程中无法申请到足够内存时就会抛 出 OutOfMemoryError 异常。

​	设置栈内存的参数 -Xss 设置线程的最大栈空间

2. 栈帧
	栈帧内部存放着 局部变量表、操作数栈、动态链接 以及方法的返回地址
	1）局部变量表：定义为一个数字数组，主要用于存储方法参数和定义在方法体内部的局部变量（包括8种基本数据类型，对象引用 reference 和 返回地址 returnAddress 类型），局部变量表的大小在编译期间就已经确定下来，在方法运行期间不能改变。 maximum local variables 
		在局部变量表中的基本存储单位为slot (变量槽)
		局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中的变量直接或间接引用的对象都不会被垃圾回收。
	2）操作数栈：操作数栈也称为表达式栈，主要用于保存计算过程中的中间结果，同时作为计算过程中变量临时存储的存储空间，与局部变量表一样在编译期间就已经确定了操作数栈的最大深度，保存在方法的Code属性中，Max_stack的值。
		如果被调用的方法带有返回值的话，其返回值会被压入到当前栈帧的操作数栈中
	3）动态链接：每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。	
    ![第09章_方法区与栈的关联结构](F:\JAVA\JVM\JVM上篇配图\JVM上篇配图\第09章_方法区与栈的关联结构.jpg)
    作用：将指向常量池的符号引用转化为调用方法的直接引用。
    目的就是为了能够支持当前方法能够实现动态链接。
	4）方法返回地址：存放调用该方法的PC寄存器的值
		一个方法的结束有两种形式：正常执行完成 和 出现未处理异常，非正常退出
		当方法正常退出时，调用者PC寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址；当异常退出时，返回地址是通过异常表来确认的，栈帧中不会保存这部分数据。
## 3. 本地方法栈和本地方法接口
目的：为虚拟机提供Native方法服务
Java虚拟机栈主要用于管理java方法的调用，而本地方法栈用于管理本地方法的调用，也是线程私有的，也会出现OOM和栈溢出异常
一个 Native Method 就是一个java调用非java代码的接口
Q: 为什么要使用本地方法？
1. 与java环境外交互的需求，例如与操作系统或者某些硬件交换信息时
## 4. 堆
1.定义：堆是JVM管理的最大的一块内存区域，几乎所有的对象实例都分配在堆空间中，也是垃圾回收的重点区域，一个JVM实例只存在一个堆内存，所有线程共享java堆，在堆里也可以划分线程私有的缓冲区（Thread Local Alloction Buffer TLAB）
2.堆区可以进一步细分为年轻代和老年代，年轻代有Eden区和Survivor0区和Survivor1区
<img src="F:\JAVA\JVM\JVM上篇配图\JVM上篇配图\第08章_堆空间细节.jpg" alt="第08章_堆空间细节" style="zoom: 80%;" />
堆空间的参数设置：
-Xms 设置堆区的起始内存 等价于 -XX: InitialHeapSize
-Xmx 设置堆空间的最大内存 等价于 -XX: MaxHeapSize
-XX: NewRatio=2, 代表老年代与新生代的比例为2 ：1

3. 对象分配的过程
	new的对象先放在伊甸园区，大对象直接进入老年代；当伊甸园区放满时，对伊甸园区进行Minor GC，将伊甸园区中不被任何其他对象所引用的对象销毁，在加载新的对象放入伊甸园区，并将剩余对象移动到幸存者0区，再次触发Minor GC时，将存活的对象使用复制算法分配到幸存者1区，并且记录对象年龄加1，当对象存活15次后，进入养老区。当养老区内存不足时，首先触发Minor GC，然后在触发Full GC ，如果换不能放下，就报OOM异常
4. 为什么要分代？
	大部分的Java对象是朝生夕死的对象，分代的思想可以优先收集这部分对象，对于存活时间很长的对象少GC，这样可以提高垃圾回收的性能，即多进行Minor GC，收集伊甸园区和幸存者区的对象，少使用Full GC 进行全局的垃圾回收（效率很低）
5. TLAB
Q1: 为什么要有TALB？
因为堆区是线程共享的区域，任何线程都能访问到堆区的共享数据，在并发环境下是线程不安全的，如果想要避免多个线程操作同一地址，就需要使用加锁等机制，影响分配速度。
Q2: 什么是TALB？
在Eden区域进行继续划分，为每个线程提供了一个私有缓存区域，包含在Eden空间内。可以使用-XX: UseTLAB 设置开启TLAB空间，默认的TLAB空间很小，只占整个Eden区的1%，一旦对象在TLAB中创建失败，JVM就会尝试通过使用加锁机制确保数据操作的原子性，从而在Eden空间中直接分配内存
6. 堆是对象存储的唯一选择嘛？
随着JIT编译器的发展和逃逸分析技术的发展，栈上分配和标量替换技术的发展，对象分配也不绝对了；
特例一：栈上分配
如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，就可能被优化成栈上分配，也不存在垃圾回收问题。
特例二：标量替换
标量是指一个无法再被分解成更小的数据的数据，Java中原始数据类型就是标量。
在JIT阶段，如果经过逃逸分析，发现一个对象没有被外界访问，即没有发生逃逸时，就会把这个对象拆解成为多个其中包含的成员变量，来代替原来的对象，这个过程称为标量替换。
Q1: 何为逃逸分析？
当一个对象在方法中被定义后，对象只在方法内部被使用，则认为没有发生逃逸。
## 5. 方法区
### 1. 定义

​		方法区也称为非堆，可以看成一块独立于Java堆的内存空间，是各个线程共享的内存区域，在JVM启动的时候就被创建，可以选择固定大小或者可扩展。方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，也同样会报OOM异常（java.lang.OutOfMemory: Metaspace）比如加载过多的第三方jar包

### 2. 方法区的内部结构

它用于存储已经被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存。
类型信息
域信息
方法信息
non-final的类变量

------
### **运行时常量池**：

1. 运行时常量池是方法区的一部分，在Class文件中有一项信息称为常量池表，用于存放编译期间生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
2. 一般来说，除了保存在Class文件中描述的符号引用外，换回吧由符号引用翻译出来的直接引用也存储在运行时常量池中。
3. 相较于Class文件中的常量池，运行时常量池的一个重要特征就是具备动态性，即运行期间也可以将新的常量放入池中，例如String类的intern()方法
4. 既然是方法区的一部分，当常量池无法申请到内存时也会报OOM

------
Q1: jdk不同版本中方法区的变化？
在jdk7以前称为永久代，jdk8以后称为元空间 Metaspace，而且两者的最大区别是源空间不在虚拟机设置的内存中，而是直接使用本地内存，但也会存在OOM问题。
在JDK7中将原来在永久代中的字符串常量池和静态变量移到了堆中

Q2:为什么StringTabel要调整？

因为在开发中会有大量的字符串被创建，但是永久代的回收效率很低，只有在Full GC时才被触发，放到堆内，可以保证及时回收。



# 三：Java对象

## 1. Java 的对象的内存结构

对象头、实例数据和对象填充

### 1.1对象头

对象头主要包括两类信息：第一类适用于存储对象自身的运行时数据（MarkWord），如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据在32位和64位的虚拟机中分别为32个比特和64个比特。

第二类：类型指针，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。

### 1.2实例数据

实例数据用来存储对象真正的有效信息，包括程序代码中定义的各种类型的字段（包括父类继承下来的和自己定义的）

### 1.3对象填充

JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）

## 2. 对象的创建过程

1.判断对象对应的类是否加载、链接、初始化，如果没有，则必须先执行相应的类加载过程。

2.为对象分配内存：如果内存规整：指针碰撞；如果内存不规整，虚拟机需要维护一个列表，空闲列表分配（Java堆的是否规整由使用的垃圾回收器的类型决定）

3.处理并发安全问题：采用CAS配上失败重试保证更新的原子性；为每个线程预先分配一块TLAB，只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁定

4.初始化分配到的内存空间（不包括对象头）都初始化为零值，保证了对象的实例字段在Java代码中不被附初始值时也可以使用

5.设置对象的对象头，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希值等

从虚拟机的角度看，此时一个新的对象已经创建了，但是从Java程序看，对象的创建才刚刚开始--构造函数，

6.即执行Class文件中的<init>方法对对象进行初始化，这样一个真正可用的对象才算被完全构造出来

## 3. java对象实例化的方法

创建对象的方式：

new() ; 

Class的newInstance(); 

使用clone()；

使用反序列化的方法；

## 4.对象的访问定位

创建对象的目的就是为了后续的使用，Java程序会通过栈上的reference数据来操作堆上的对象。

对象访问的只要有两种方式：句柄访问和直接指针，两种方式各有优势



### :one: 句柄访问

<img src="F:\JAVA\JVM\JVM上篇配图\JVM上篇配图\第10章_方式1：句柄访问.jpg" alt="第10章_方式1：句柄访问" style="zoom:50%;" />

句柄池访问的优点：

最大好处就是reference中存储的是稳定的句柄地址，在对象被移动后也只会改变句柄中的实例数据指针，而reference本身不用修改

### :two: 直接指针（Hotspot虚拟机采用）

<img src="F:\JAVA\JVM\JVM上篇配图\JVM上篇配图\第10章_方式2：使用直接指针访问.jpg" alt="第10章_方式2：使用直接指针访问" style="zoom:50%;" />

直接指针的优点：

速度快，节省了一次指针定位的时间开销

# 四：执行引擎

## 1.什么是字节码？

字节码是一种中间状态（中间码）的二进制代码，它比机器码更抽象，需要直译器转译后才能成为机器码。典型代表就是Java bytecode. JVM的设计者的初中就是为了满足java程序的跨平台性能，因此避免采用静态编译的方式直接生成本地机器指令

## 2. 执行引擎的作用：

将字节码指令解释/编译成对应平台上的本地机器指令，输入是字节码的二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。

## 3. 为什么java又称作半解释型、半编译型语言？

### 3.1 解释器

当java虚拟机启动时会根据定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容翻译为对应平台的本地机器指令执行。

​	解释器又分为两种：一种是古老的**<u>字节码解释器</u>**，即通过纯软件代码模拟字节码的执行，效率低下；

​	另一种成为**<u>模板解释器</u>**，即将一条字节码和一个模板函数相关联，模板函数能直接产生这条字节码执行时的机器码，从而提高解释器的执行效率。

### 3.2 JIT(Just In Time Compiler)即时编译器

就是虚拟机将源代码直接编译成和本地机器指令平台相关的机器语言。

现在的java代码在执行的时候，都会将解释执行和编译执行二者相结合起来，当虚拟机启动的时候，解释器可以首先发挥作用，不必等待即时编译器全部编译完成再执行，可以省去不必要的编译时间，并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译成为本地机器代码指令，以换取更高的执行效率。

## 4.热点探测

### 1.热点代码主要包括两类：

一类是多次被调用的方法：（通过方法调用计数器计算）

另一类是多次被执行的循环体：（通过回边计数器计算），这种编译方式因为发生在方法执行的过程中，即方法的栈帧还在栈上，所以也称作栈上编译(On Stack Replacement, OSR)

Hotspot 虚拟机采用的是基于计数器的热点探测技术：

### 2.热点探测的过程

当一个方法被调用时，首先检测该方法是否存在JIT编译过的版本，如果存在，则优先使用编译后的本地代码执行，如果不存在，则将该方法的调用计数器+1，然后判断方法调用计数器与回边计数器之后是否超过调用计数器的阀值，如果超过，就向即时编译器提交一个该方法的代码编译请求，同时，执行引擎不会同步等待编译请求完成，而是继续按照解释方式执行字节码；

### 3. C1 和 C2 编译器 以及分层编译

C1编译器：对字节码进行简单和可靠的优化，耗时短，编译速度快

C2编译器：耗时较长，会采用激进优化，但代码执行效率更高，会在采用性能监控的前提下，进行逃逸分析，并采取标量替换、栈上分配和同步消除等优化

分层编译：同时开启C1和C2编译器，综合了 C1 的高启动性能及 C2 的高峰值性能。

这两个 JIT compiler 以及 interpreter 将 HotSpot 的执行方式划分为五个级别：

level 0：interpreter 解释执行。
level 1：C1 编译，无 profiling（性能监控）
level 2：C1 编译，仅方法及循环 back-edge 执行次数的 profiling
level 3：C1 编译，除 level 2 中的 profiling 外还包括 branch（针对分支跳转字节码）及 receiver type（针对成员方法调用或类检测，如 checkcast，instnaceof，aastore 字节码）的 profiling
level 4：C2 编译
![image-20210818125445655](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210818125445655.png)

分层编译关系：

![image-20210818125526958](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210818125526958.png)

上图列举了4 种编译模式（非全部）。通常情况下，一个方法先被解释执行（level 0），然后被C1 编译（level 3），再然后被得到profile 数据的C2 编译（level 4）。如果编译对象非常简单，虚拟机认为通过C1 编译或通过C2 编译并无区别，便会直接由C1 编译且不插入profiling 代码（level 1）。在C1 忙碌的情况下，interpreter 会触发profiling，而后方法会直接被C2 编译；在C2 忙碌的情况下，方法则会先由C1 编译并保持较少的profiling（level 2），以获取较高的执行效率（与3 级相比高30%）。

# 五：垃圾回收相关算法及概念

GC最基础的垃圾回收算法有三种：标记-清除算法、复制算法、标记-压缩算法；

## 1.标记-清除算法

“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：

**标记**：首先从根节点遍历，标记所有被引用的对象

**清除**：对对空间进行线性遍历，如果发现某个对象没有标记为可达对象，就将其回收。

缺点：效率不高，而且需要停止整个用户进程，整理出来的内存不是连续的，有内存碎片，需要维护一个空闲列表

## 2.复制算法

“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

优点：不会产生内存碎片

缺点：需要两倍的内存空间，特别适合垃圾对象较多的区域回收（例如新生代）

## 3.标记-压缩算法

标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

优点：消除了标记-清除算法的内存碎片问题，消除了复制算法，内存减半的高额代价

缺点：效率上低于复制算法，而且移动对象的同时，换需要调整对象被别人引用的地址，移动过程中全程要STW

## 4. 分代收集算法

分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。

## 5、新生代与复制算法

​	目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor 空间中。

## 6、老年代与标记复制算法

老年代的特点：区域较大，对象生命周期长、存活率高，回收不频繁

这种情况下，因为存在大量的对象，复制算法就变得不合适，一般是由标记-清除或者标记-清除与标记-整理混合实现。

## 7.判断对象是否存活的方式

（1）JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)， 它用来存储 class 类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。

（2）对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目前存放对象的那一块)，少数情况会直接分配到老生代。

（3）当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后， Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理。

（4）如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。

（5）在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。

（6）当对象在 Survivor 去躲过一次 GC 后，其年龄就会+1。 默认情况下年龄到达 15 的对象会被移到老生代中。

## 7.判断对象是否存活的方式

### 引用计数算法

实现简单，便于识别，判定效率高，回收没有延时性，主要问题是没有办法处理循环引用问题

### 可达性分析算法（JVM采用的方法）

以根对象集合为起始点，按照从上至下的搜索方式搜索被根对象集合连接的目标对象是否可达。

### GC Roots

Java语言中的GC Roots主要包括以下几类对象：

在虚拟机栈中引用的对象，例如各个线程被调用的方法堆栈中的参数，局部变量、临时变量；

方法区中类静态属性引用的对象；

字符串常量池中的引用；

本地方法栈中本地方法引用的对象；

Java虚拟机内部的引用，如基本数据类型对应的Class对象，以及一些常驻的异常对象，系统类加载器等；

所有被同步锁持有的对象；

## 8.对象的finalization机制

垃圾回收此对象前，都会先调用这个对象的finalize()方法，所以由于finalize()方法的存在，虚拟机中的对象一般会有三种状态

可触及的：从根节点开始，可以到达这个对象

可复活的：对象的所有引用都被释放，但是对象可能在finalize()中被复活

不可触及的：对象的finalize()被调用，但是没有复活，就进入了不可触及状态，因为finalize()方法只能被调用一次。

## 9. 内存泄漏和内存溢出

解决OOM异常时，一般的手段是首先通过内存映像分析工具对dump文件进行分析，分析是出现了内存泄漏还是内存溢出？
内存泄漏：是指该对象已经不再使用了，但是还是关联在GC Roots上，导致不能被及时回收，长时间的内存泄漏就会导致内存溢出。例如：没有手动的close数据库的连接，网络连接和io连接
内存溢出就是OOM：解决内存溢出就是首先看给定的堆参数（-Xmx和-Xms是否合理），某些对象的生命周期是否过长，尝试减少程序运行期间的内存消耗

## 10. java的四种引用

### :one: 强引用

java程序中最常见的普通对象引用，也是默认的引用类型，无论任何情况下，只有强引用关系还在，垃圾回收器就不会回收被引用的对象。也是造成java内存泄漏的主要原因

例子： Object obj = new Object()

### :two: 软引用

只要是被软引用关联着的对象，在系统将要发生内存溢出异常之前，会把这部分对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会报出内存溢出异常

例如：高速缓存就使用到了软引用，在有空闲内存时保存缓存，内存不足是清除缓存。

```java
Object obj = new Object();	// 声明强引用

SoftReference<Object> sf = new SoftReference<Object>(obj);	// 绑定软引用

obj = null;	// 销毁强引用，只剩下软引用
```

### :three: 弱引用

发现即回收，只要被弱引用关联的对象只能生存到下一次垃圾收集行为发生为止；弱引用用来描述那些非必须对象，在系统GC时，只要发现，不管系统堆空间使用是否充足，都会回收纸杯弱引用关联的对象；

例如：WeakHashMap

```java
Object obj = new Object();	// 声明强引用

WeakReference<Object> sf = new WeakReference<Object>(obj);	// 绑定弱引用

obj = null;	// 销毁强引用，只剩下软引用
```

### :four: 虚引用

虚引用，又称为"幽灵引用"或者”幻影引用“，仅持有虚引用和没有引用一样，无法通过虚引用找到被引用的对象，也随时会被垃圾回收器回收，设置虚引用的唯一目的就是在于跟踪垃圾回收过程。

例如：能在这个被虚引用指向的对象被回收时收到一个系统通知

## 10. System.gc( ) 与 Runtime.getRuntime( ).gc

两者的作用一样，都会显示的触发Full GC，同时对老年代和新生代进行回收，两者都是提醒jvm的垃圾回收器进行Full GC，但是不确定具体的执行时间（在安全点或安全区域才执行）

## 11. 安全点和安全区域

### :one: 安全点

程序并非在所有的地方都可以停顿下来进行GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点”。

### :two: 安全区域

安全区域是指在一段代码片段中，对象的引用关系都不会发生变化，在这个区域的任何位置内开始GC都是安全的，也可以看成是安全点的扩充。

### 安全点的选择

一般会选择那些会让程序长时间执行的地方，例如方法的调用，循环跳转或者异常跳转的地方。

### 如何检查所有的线程都跑到了最近的安全点？

抢断式中断（目前没有虚拟机采用）：首先中断所有线程，并将不在安全点的线程恢复，让他跑到最近的安全点。

主动式中断：设置一个中断标志，各个线程运行到Safe Point就去主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。

# 六：垃圾回收器介绍

## 1.垃圾回收器之间的组合关系

![第17章_垃圾收集器组合](F:\JAVA\JVM\JVM上篇配图\JVM上篇配图\第17章_垃圾收集器组合.jpg)
红色虚线：在JDK8中声明为废弃，在JDK9中正式取消的两个组合

绿色虚线：在JDK14中启用了

青色虚线：在JDK14中删除了CMS垃圾回收器

已知的几个搭配，根据具体的使用场景，选择最合适的垃圾收集器。

在单CPU情况下的串行组合：Serial GC 和 Serial Old GC 

并行模式：Paraller Scavenge GC 和 Parallel Old GC 

G1收集器

ParNew GC + CMS GC( 备用 Serial Old GC)   此搭配随着JDK14删除CMS GC 而退出历史舞台

### 各个版本中的默认垃圾回收器

**jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）**

**jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）**

**jdk1.9 默认垃圾收集器G1**

## 2. Serial串行回收器

Serial GC 和 Serial Old GC  单线程垃圾回收器

其中Serial GC负责年轻代的回收，使用复制算法、串行回收和STW机制的方式执行内存回收

Serial Old GC 提供老年代的垃圾回收，采用标记-压缩算法、串行回收和STW

优势：简单而高效，针对于单个CPU的环境，没有线程交换的开销，效率较高，也是HotSpot虚拟机在Client模式下的默认垃圾回收器

## 3. ParNew并行回收器

可以说ParNew收集器是Serial收集器的多线程版本，其中Par是Parallel并行的缩写，New：是指只能处理年轻代

复制算法+STW+多线程，在多CPU环境下，可以充分利用硬件资源，加速垃圾回收，只能搭配Serial Old GC 或者 CMS GC 一起使用。

## 4. Parallel回收器

一种**吞吐量**优先的并行垃圾回收器

Parallel Scavenge 收集器与 ParNew 收集器相似 同样采用 **复制算法+STW+并行回收**，但是与其不同的是，Parallel Scavenge收集器目标是**可控制的吞吐量**，Parallel Scavenge也是两者之间的一个重要差别。

Parallel Old 采用 标记-压缩算法 + STW + 并行回收

## 5. CMS回收器

主打低延迟，关注点是尽可能缩短垃圾收集时的用户线程的停顿时间。第一款真正意义上的并发收集器，实现了垃圾回收线程与用户线程同时工作。

作为一款老年代的收集器，因为架构的问题无法和新生代的 Parallel Scavenge 配合工作，新生代只能选择 ParNew 或 Serial收集器中的一个

### CMS回收过程：

:one: 初始标记：这一阶段是STW的，但是因为仅仅标记GC Roots能直接关联到的对象，所以暂停时间较短

:two: 并发标记：从GC Roots直接关联的对象开始遍历整个对象图，这个过程耗时较长，但是不需要停顿用户线程，可以与垃圾收集器一起并发运行。

:three: 重新标记：修正在并发标记阶段产生变动的对象的标记记录。

:four: 并发清除：清除掉标记为死亡的对象，因为不需要移动，所以也可以和用户线程并发。

注意点：

1. 因为CMS在回收过程中，用户线程换需要运行，所以需要设置一个阈值，到达阈值就开始垃圾回收，而不能像其他回收器一样等老年代快被填满时才回收。如果在CMS运行期间内存溢出，就会出现依次“Concurrent Mode Failure”，启动后备的Serial Old 对老年代重新回收，这样停顿时间就更长了
2. 因为CMS采用的是标记清除算法，所以不可避免的会产生一部分的内存碎片，在新对象分配时没法使用指针碰撞技术，而是只能维护一个空闲列表，所以设计者设置了一个参数-XX: CMSFullGCsBeforeCompaction 用于指定在执行若干次不整理空间的Full GC 后，下一次Full GC 会先进行碎片整理。
3. CMS对于CPU资源敏感，虽然在并发阶段，不会导致用户进程停顿，但是也会因为占用了一部分的线程资源，而导致应用程序缓慢，总吞吐量下降。

## 6. Garbage First (G1) 收集器

G1收集器主要是为了适应现在不断扩大的内存和不断增加的处理器数量，在延迟可控的情况下获得尽量高的吞吐量，开创了基于Region的堆内存布局形式。



### 1.G1收集器的回收过程

![第17章_G1-GC垃圾回收过程](F:\JAVA\JVM\JVM上篇配图\JVM上篇配图\第17章_G1-GC垃圾回收过程.jpg)

G1 GC 的垃圾收集过程主要包括三个环节：年轻代GC，老年代的并发标记和混合回收。

当年轻代的Eden区用尽时开始年轻代的回收过程，G1的年轻代收集器是一个并行的独占式收集器。在年轻代回收期间，G1 GC暂停所有的应用线程，启动多线程执行年轻代回收，然后从年轻代区间移动存活对象到Survivor 区或老年区。

当堆内存的使用到到一定值(默认是45％)时，开启老年代的并发标记过程。

标记完成后立刻开始混合回收，G1的老年代回收器只针对一小部分老年代的的Region就可以。

在这三个阶段中，都会存在年轻代GC 的身影，也满足频繁回收年轻代，少量回收老年代的思路。

G1收集器主要可以分为以下四个步骤：

:one: 初始标记：仅仅标记根节点可直接到达的对象，需要STW，但是耗时很短，往往也是个Minor GC 同步完成的；

:two: 并发标记：从 GC roots开始对堆中的对象进行可达性分析，可与用户进程并发执行。

:three: 最终标记：修正上一次标记的结果，是STW的，G1中采用了比CMS更快速的初始快照算法SATB

:four: 筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来指定回收计划，自由选择任意多个Region组成回收集，然后再把确定要回收的Region的存活对象复制到空的Region中，并回收掉旧的Region的全部内容。

Q:G1的主要应用场景?

面向服务端应用，针对具有大内存、多处理器的机器；最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案.

### 2.G1收集器与CMS收集器的区别：

G1的优点：

:one: 可以指定的最大停顿时间，分Region的内存布局和安收益动态确定回收集的创举；

:two: 在算法理论上也不相同：CMS 采用了标记-清除算法，而G1从整体看采用的是基于标记-整理算法，从局部看（两个Region之间看）才用的是标记-复制算法，意味着G1在运作期间会产生更少的内存碎片，垃圾收集完毕后能提供规整的可用内存，有利于程序的长时间运行。

G1 的缺点：

G1 相对于CMS 仍然不具有全方位的，压倒性优势，主要的问题就在于G1为了垃圾收集产生的内存占用和程序运行是的额外执行负载都比CMS要高，比如CMS 和 G1 都是用卡表来处理跨代指针，但是G1的卡表更加的复杂，而且堆中的每个Region，无论扮演年轻代还是老年代角色都会保存一份卡表，导致G1的记忆集会占到整个堆内存的20%，相比来说CMS的卡表就相当简单。



所以CMS再小内存的性能更加优秀，而G1则在大内存的方面更加优秀，这个分水岭大概在6-8GB。



### 3.三色标记和读写屏障

三色标记法：要找出存活的对象，根据可达性分析算法，就要从GC Roots开始遍历访问，可达则为存活对象。可将对象分为三种情况：

:black_circle: (Black)： 自己已经完成标记，且本对象的引用到的其他标记也已经全部访问。

🟤 (grey)：本对象已经访问结束，但是本对象的引用还没有全部访问

:white_circle: (White)：尚未完全访问

#### 三色标记法的标记流程

1. 初始时，所有对象都在 【白色集合】中，

2. 将GC Roots 直接引用到的对象 挪到 【灰色集合】中。

3. 从灰色集合中获取对象：
    3.1. 将本对象 引用到的 其他对象 全部挪到 【灰色集合】中；

  3.2. 将本对象 挪到 【黑色集合】里面。

4. 重复步骤3直至【灰色集合】为空时结束。
5. 结束后仍在【白色集合】的对象即为GC Roots 不可达，可以进行回收。



所以对于STW时，对象的引用关系是不会改变的，可以轻松完成标记，但是并发标记过程中，应用线程还在工作，对象之间的引用关系就可能产生变化，就可能存在多标和漏标的情况。

#### 多标-浮动垃圾

![image-20210819173225489](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210819173225489.png)

此时假设执行了如下语句，即断开了D-F的指针，但是因为此时E已经被标记为了灰色，仍将其作为存活对象进行标记，结果这就这部分本就应该删除的对象仍被标记为存活，等到下一轮才能被回收；如果在并发标记期间产生了新的对象，也会直接标记为黑色，本轮标记不会清除，如果这部分对象变成了垃圾，也算作是浮动垃圾的一部分。

```java
objD.fieldE = null
```

#### 漏标

![image-20210819173829943](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210819173829943.png)

假设GC线程已经遍历到了E（变为了灰色），而此时应用线程执行了：

```java
var G = objE.fieldG; 						// 读
objE.fieldG = null;  // 灰色E 断开引用 白色G      写
objD.fieldG = G;  // 黑色D 引用 白色G            写
```

此时切换回GC线程继续跑，因为E已经没有对G的应用了，所以不会将G放到灰色集合中；尽管因为D重新引用了G，但是因为D已经是黑色了，不会再做重新的遍历，导致的结果就是G会一直在白色集合中，最后被当做垃圾回收，这个后果是不被允许的。

漏标有两个必要的条件，缺一不可：

条件1：黑色对象重新引用了该白色对象。

条件2：灰色对象断开了对白色对象的引用；即灰色对象的引用发生了变化。

所以解决的办法也很简单，就是打破其中的任意一条条件，由此产生了两种解决方案：增量更新(Incremental Update)和原始快照（Snapshot At The Beginning, SATB）；

#### :one: 增量更新

增量更新破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等待并发扫描结束之后，再讲这些记录过的引用关系中的黑色对象作为跟，再重新扫描一次。

#### :two: 原始快照

原始快照破坏的是第二个条件，当灰色对象要删除只想白色对象的引用时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过得引用关系中的灰色对象为根，重新扫描一次。可以简单的理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索扫描

其中写屏障用于拦截第二和第三步，读屏障拦截第一步，目的就是在读写的前后将对象G记录下来。



## 7.垃圾回收中的一些参数使用

输出GC日志： -XX: +PrintGCDetails



# 七：类的加载过程

## 1.类的生命周期

<img src="F:\JAVA\JVM\官方笔记\JVM中篇：字节码与类的加载篇\图示\中篇_第3章：类的生命周期.png" alt="中篇_第3章：类的生命周期" style="zoom:80%;" />

类的声明周期主要有五个过程，加载，链接，初始化，使用和卸载。其中前三个阶段为类加载的执行过程，链接阶段又可分为验证，准备和解析三部分。

### :one: 加载：

加载阶段主要就是通过一个类的全限定名来获取定义此类的二进制字节流（这个字节码文件可以从多种途径获取，只要字节码符合JVM的规范即可，否则会爆ClassFormatError）,将这个字节流代表的类的静态存储结构转换成方法区的运行时数据结构，并在堆中实例化一个java.lang.Class的对象没座位程序访问方法去中类型数据的外部接口。

### :two: 链接阶段：

链接阶段包括验证，准备和解析三部分。

#### 验证：

目的是保证加载的字节码是合法、合理并符合规范的，主要包括类数据信息的格式检验、语义检查、字节码验证以及符号引用验证等。其中格式检验会和加载阶段一起执行，检验通过或，类加载器就会成功的将类的二进制数据信息加载到方法区内，剩下的步骤在方法区内部进行。

<img src="F:\JAVA\JVM\官方笔记\JVM中篇：字节码与类的加载篇\图示\中篇_第3章：验证阶段的检查.png" alt="中篇_第3章：验证阶段的检查" style="zoom: 67%;" />

#### 准备：

就是为类的静态变量分配内存，并将其初始化为默认值。

注意：非 final的类变量（static）在准备阶段进行默认初始值，而final static的类变量在准备阶段直接进行显示赋值。

#### 解析：

将类、接口、字段和方法的符号引用转换为直接引用。

##### 符号引用 vs 直接引用：

符号引用就是一堆字面量的引用，与虚拟机的内部数据结构及内存布局无关。通过解析操作，符号引用就可以转变成为（目标方法）在类中方法表的位置，从而使得方法被成功调用。

### :three: 初始化阶段

简而言之就是将类的静态变量赋予正确的初始值，类的初始化是类装载的最后一个阶段，此时类才开始执行java字节码，初始化阶段最重要的事情就是执行类的初始化方法:<client>()方法，该方法是由类静态成员变量的赋值语句以及static语句块合并产生的（不是必须的，当一个java程序没有static代码块，没有对类变量进行显示赋值时，或者包含static final的常量字段时都没有<client>方法），且父类的<client>方法优先于子类的<client>

#### 主动使用和被动使用

Java虚拟机规定一个类或接口在初次主动使用前，必须进行初始化，

主动使用主要包括

1.创建一个类的实例，比如使用new关键字，反射，克隆或者反序列化。

2.调用了当前类的静态方法时。

3.使用类、接口的静态字段时，比如getstatic或者putstatic指令（对应访问静态变量或者给静态变量赋值）

4.使用java.lang.reflect包中的反射类的方法。

5.当初始化子类时，发现其父类没有初始化，则先触发其父类的初始化。

6.当虚拟机启东市，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个类。

被动使用：

1.当访问一个静态字段时，只有真正声明这个字段的类才被初始化。例如：当通过子类引用父类的静态变量时，不会导致子类的初始化。

2.通过数组定义类引用，不会触发此类的初始化，只给数组开辟了空间，只有当使用时才初始化。

3.引用常理不会触发此类或接口的初始化，因为在链接阶段已经被显示赋值了。

### :four: 类的使用

包括开发人员在程序中访问它的静态类成员信息（静态字段、静态方法），或者使用new关键字为期创建实例对象，都是对类的使用。8977

### :five: 类的卸载

当代表Sample类的Class对象（在堆中）不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。

方法区的垃圾回收主要是两个方面：

1. 常量池中废弃的常量（只要常量池中的常量没有被任何地方引用，就可以被回收）

2. 不再使用的类型。这个就相对比较困难，首先该类的所有实例要都已经被回收，加载该类的类的加载器已经被回收，该类对应的java.lang.Class对象没有任何地方被引用，而且一个应经被加载的类是很难被卸载的。

## 补：类加载的执行过程？

<img src="F:\JAVA\JVM\官方笔记\JVM中篇：字节码与类的加载篇\图示\中篇_第3章：类的加载过程.png" alt="中篇_第3章：类的加载过程" style="zoom: 80%;" />

主要分为3个阶段：加载、链接、初始化 
   加载：通过类的全限定名获取定义此类的二进制字节流，并放到方法区中，然后在内存中生成一个代表这个类的Class对象，作为方法区中这个类的访问入口 
   链接：链接阶段分为3个部分：验证、准备、解析 
   	验证：确保上面的class文件二进制字节流中包含的信息符合当前虚拟机要求，保证类加载的正确性 
   	准备：为类变量分配内存，并且设置该类变量的默认初始值（如int型默认设为0，boolean型默认设为false） 
   	解析：将方法区的运行时常量池中的符号引用转换为直接引用。所谓的符号引用就是使用一组符号来表示引用的目标，因为在编译阶段，编译成的.class文件				并不知道实际引用类的内存地址，所以只能用符号引用来代替。比如说People类中引用了Tool类，在编译时，People类并不知道Tool类的实际内存地				址，因此只能使用一组符号表示Tool类的地址。而直接引用是直接指向目标的指针。 
   初始化：执行类构造器方法<clinit>()，此方自动收集所有类变量的赋值动作（内存已经在准备阶段分配完毕）和静态代码块中的语句合并而来并执行。

## 2.什么是类的加载器，有哪些类的加载器

ClassLoader 是java的核心组件，所有的Class都是有类的加载器加载的，负责通过各种方式将Class信息的二进制数据数据读入到 JVM 内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给java虚拟机进行连接、初始化等操作

JVM支持两种类型的类加载器，分别为启动类加载器和其他类加载器。其中，启动类加载器是由C++语言实现的，是虚拟机自身的一部分；另一部分就是其他的所有类加载器，这些类加载器都由java语言实现，独立于虚拟机外部，并且全部继承于java.lang.ClassLoader;

启动类加载器（Bootstrap Class Loader）：负责加载java的核心类库（按照文件名称识别，例如rt.jar、tools.jar）是由C++语言编写的，无法在java程序中直接调用，挡在用户自定义类中想把加载委托给引导类加载器时，直接使用null代替。

扩展类加载器（Extension Class Loader）：由java语言编写，负责加载由系统参数java.ext.dirs所指定吗目录中的类库，以扩展Java SE 的功能，它的父加载器是启动类加载器。

应用程序类加载器，也称作系统类加载器：他是应用最广泛的类加载扎起，从用户路径Classpath或者系统属性java.class.path指定的目录中的所有类库，如果应用程序中没有自定义过自己的类加载器，他就是程序默认的类加载器。

用户自定义加载器：ClassLoader是一个抽象类，好多方法没有具体的实现，比如findClass 和findResource，而URLClassLoader这个实现类为这些方法提供了具体的实现，用户在自定义类加载器是，可以直接继承这个，免去获取字节流的方式和编写findClass方法。

Q: 为什么需要自定义加载类？

1. 用于隔离加载类
2. 防止源码泄漏
3. 扩展加载源

<img src="C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210820162201407.png" alt="image-20210820162201407" style="zoom: 80%;" />



## 3.双亲委派机制

图中的各种类加载器之间的层次关系称为类加载器的“双亲委派模型”。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，如果一个类收到了类加载的请求，他不会自己去尝试加载这个类，而是把这个请求委托给它的父类加载器去完成，最终所有的请求都会传递到最顶层的启动类加载器中，只有当父类加载器无法完成这个加载请求时（即它的搜索范围内没有找到这个类），子类加载器才会去尝试自己去完成加载。

双亲委派机制的代码在java.lang.ClassLoader的loadClass()方法中体现

比如说自己定义一个java.lang包，并创建一个String类，当程序进行String类加载时，原先是由系统类加载器进行加载的，但由于双亲委派模式的存在，所以会委托给顶层的引导类加载器进行核心类库中String类的加载，从而导致自己定义的String类无法被加载。好处就是提高代码的安全性，防止API被恶意篡改

### 优点：

1. 避免类的重复加载，确保一个类的全局唯一性。
2. 保护程序安全，防止核心API被随意篡改。

### 弊端：

检查类的是否加载的委托过程是单向的，会导致顶层的ClassLoader无法访问地城的ClassLoader加载的类。例如：当应用类访问系统类时没有问题，但当系统类访问应用类就会出现问题

### 破坏双亲委派机制：

双亲委派机制并不是一个具有强制性约束的模型，而是java设计者推荐给开发者的类加载器的实现方式。所以直到java模块化开始，双亲委派机制总共有三次大规模的破坏行为。

1. 因为双亲委派机制出现于jdk1.2之后，而类加载器的概念和抽象类java.lang.ClassLoader早在第一个版本就有。
2. 则是因为双亲委派机制本身的缺陷，则添加了一个线程上下文加载器，使用这个加载器去加载需要的代码，打破双亲委派机制。
3. 热替换的需求。

## 4.沙箱安全机制

java安全模型的核心就是沙箱安全机制：目的就是保护程序安全和原生JDK代码。沙箱就是一个限制程序运行的环境，使得java代码限定在JVM的特定运行环境中，严格限制对于本地系统资源的访问，通过这样保证对代码的隔离，防止对本地系统造成破坏。

## 5. JDK9的新特性：模块化

### 模块化下的类加载器

1. 首先的变化是，取消了扩展类加载器，被平台类加载器。
2. 平台类加载器和应用类加载器不在继承于java.net.URLClassLoader，现在启动类加载器、平台类加载器和应用程序类加载器都继承于jdk.internal.loader.BuiltinClassLoader。
3. 虽然jdk9依然维持着三层类加载器和双亲委派机制，但是有所不同，当平台以及应用程序类加载器收到类加载请求时，在委派给父类加载器之前，首先判断该类是否能够归属于到某一个系统模块中，如果可以找到这样的归属关系，就优先委派给负责哪个模块的加载器完成加载。
4. ![img](https://kityminder-img.gz.bcebos.com/2b71939323af14114274c85e8d27cd2bd5190d5d)

# JVM调优

## 1.说一下 jvm 调优的工具？

jdk自带的有jconcole，jvisualvm

eclipse提供的MAT

## 2、常用的 jvm 调优的参数都有哪些？

-Xms：初始堆空间内存（默认为物理内存的1/64）

-Xmx：最大堆空间内存（默认为物理内存的1/4）

-XX: NewRatio：设置老年代与新生代在堆结构的占比

-XX: SurvivorRatio：设置新生代中Eden和S0/S1空间的比例

-XX: +PrintGCDetails：输出详细的GC处理日志

-XX: PermSize：设置初始分配的永久代大小

-XX: MaxPermSize：设置永久代最大可分配空间

-XX: MetaspaceSize：设置元空间初始分配空间

-XX: MaxMetaspaceSize：设置元空间最大可分配空间



-XX: +TraceClassLoading   追踪类的加载信息并打印






# 面试问题

