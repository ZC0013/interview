# 存在问题

## Hash索引

主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。

检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有Memory等。

MySQL目前有Memory引擎和NDB引擎支持Hash索引。

## full-text全文索引

## R-Tree空间索引

# 索引应用场景

## 哪些情况需要创建索引

1. 主键自动建立唯一索引
2. 频繁作为查询条件的字段
3. 查询中与其他表关联的字段，外键关系建立索引
4. 单键/组合索引的选择问题，高并发下倾向创建组合索引
5. 查询中排序的字段，排序字段通过索引访问大幅提高排序速度
6. 查询中统计或分组字段

## 哪些情况不要创建索引

1. 表记录太少
2. 经常增删改的表
3. 数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）
4. 频繁更新的字段不适合创建索引（会加重IO负担）
5. where条件里用不到的字段不创建索引



# 面试准备问题：

## MVCC

## 事务日志

## MySQL常见瓶颈

- CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候
- IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候
- 服务器硬件的性能瓶颈：top，free，iostat 和 vmstat来查看系统的性能状态

## 性能下降SQL慢 执行时间长 等待时间长 原因分析

- 查询语句写的烂
- 索引失效（单值、复合）
- 关联查询太多join（设计缺陷或不得已的需求）
- 服务器调优及各个参数设置（缓冲、线程数等）
- 并发场景下的 锁 和 并发连接线程数量问题
- 磁盘IO问题

## MySQL常见性能分析手段

在优化MySQL时，通常需要对数据库进行分析，常见的分析手段有**慢查询日志**，**EXPLAIN 分析查询**，**profiling分析**以及**show命令查询系统状态及系统变量**，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。

```mysql
explain select * from t; -- 分析当前查询语句
show processlist ——查看当前SQL执行，包括执行状态、是否锁表等
```

### EXPLAIN 分析查询

**Extra**（包含不适合在其他列中显示但十分重要的额外信息）

1. using filesort: 说明mysql会对数据使用一个外部的索引排序，不是按照表内的索引顺序进行读取。mysql中无法利用索引完成的排序操作称为“文件排序”。常见于order by和group by语句中
2. Using temporary：使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。
3. using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错，如果同时出现using where，表明索引被用来执行索引键值的查找；否则索引被用来读取数据而非执行查找操作
4. Using index condition：即代表本次查询会利用到索引，且会利用到索引下推。
5. using where：使用了where过滤
6. using join buffer：使用了连接缓存
7. impossible where：where子句的值总是false，不能用来获取任何元祖
8. select tables optimized away：在没有group by子句的情况下，基于索引优化操作或对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化
9. distinct：优化distinct操作，在找到第一匹配的元祖后即停止找同样值的动作

### 慢查询日志

MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 `long_query_time` 值的 SQL，则会被记录到慢查询日志中。

- `long_query_time` 的默认值为10，意思是运行10秒以上的语句
- 默认情况下，MySQL数据库没有开启慢查询日志，需要手动设置参数开启

```mysql
# 慢日志相关参数
SHOW VARIABLES LIKE '%slow_query_log%'	-- 查看事故开启
SHOW VARIABLES LIKE 'log-slow-queries'  -- 查看慢日志存放位置

# 修改 my.cnf 用久配置 慢开启日志
slow_query_log = ON
slow_query_log_file = /var/lib/mysql/hostname-slow.log		-- 慢日志存放位置
long_query_time = 3

```

所以MySQL提供了日志分析工具**mysqldumpslow**

得到返回记录集最多的10个SQL

```mysql
mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log
```

得到访问次数最多的10个SQL

```mysql
mysqldumpslow -s c -t 10 /var/lib/mysql/hostname-slow.log
```

得到按照时间排序的前10条里面含有左连接的查询语句

```mysql
mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/hostname-slow.log
```

也可以和管道配合使用

```mysql
mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log | more
```

## 性能优化

**永远小标驱动大表（小的数据集驱动大的数据集）**

**order by关键字优化**

order by子句，尽量使用 Index 方式排序

## MySQL分库分表

### 1. MySQL分表

分表有两种分割方式，一种垂直拆分，另一种水平拆分。主要用于解决单表数据量过大的问题

**垂直拆分**

垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。

**水平拆分(数据分片)**

单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。

水平分割的几种方法：

- 使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。
- 还可根据时间放入不同的表，比如：article_201601，article_201602。
- 按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。
- 根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。

![img](md_image/1734bff39ffffdd1tplv-t2oaga2asx-watermark.awebp)

#### 分表的实际场景

以交友平台用户中心的user表为例，单表数据规模达到千万级别时，你可能会发现使用用户筛选功能查询用户变得非常非常慢，明明查询命中了索引，但是，部分查询还是很慢，这时候，我们就需要考虑拆分这张user表了。

我以最典型的应用场景：用户筛选功能，以查询年龄在18到24岁的100位女性用户为例：

在单表的情况下，我们的SQL是这么写的：

```mysql
SELECT * FROM user WHERE age >= 18 AND age <= 24 AND sex = 0 LIMIT 100
```

但是，拆分user表后，用户记录分散到了多张表，比如，分散到`user_1`，`user_2`，`user_3`这三张表，此时，要查询满足上面条件的用户，我们的查询过程就变成这样：

1. 遍历`user_1`到`user_3`这三张表
2. 分别从三张表找出满足条件的用户，即执行上面的SQL
3. 合并这些用户记录
4. 从合并结果中过滤出前100名用户记录

通过对比，我们会发现**分表后的查询过程跟单表相比，变化是比较大的，这势必导致我们不得不修改代码，如果系统内类似的情况很多，那么，可能引发系统较大规模的业务逻辑改动**，所以，在系统真正出现数据库性能瓶颈前，必须提前规划分表方案，预留时间去做系统改造。

#### 分表的时机

一般的影响数据库查询的因素：

在并发场景下：锁被占用，并发连接线程过多

一般场景：磁盘IO的性能瓶颈

所以优化数据查询的首要问题是，尽量减少数据查询的磁盘IO。

**MySQL为了避免查询时都从磁盘读取查询结果，所以，在磁盘和应用之间加了一层内存，尽可能将磁盘数据加载到内存，那么，下次查询请求访问MySQL时，可以从内存中获取查询结果，避免了过多的磁盘IO的读取**。

![image-20210126223939325.png](md_image/f213f5783aca4968ab50c584893daf97tplv-k3u1fbpfcp-watermark.awebp)

所以尽量保证表单的数据规模不要超过 InnoDB Buffer Pool （包括索引、记录、AHI、数据字典）的大小，超过时就要进行分表。

### 2. MySQL分库

用于解决大规模的并发输入问题

一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。

优点：

- 减少增量数据写入时的锁对查询的影响
- 由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短

但是它无法解决单表数据量太大的问题



### 字节跳动基础架构宣讲，以及字节数据库架构体系

![image-20211214215001286](md_image/image-20211214215001286.png)



![image-20211214215024653](md_image/image-20211214215024653.png)



![image-20211214215241870](md_image/image-20211214215241870.png)



![image-20211214215354328](md_image/image-20211214215354328.png)

云上三板斧：计算、存储、网络

![image-20211214215442363](md_image/image-20211214215442363.png)



![image-20211214215637269](md_image/image-20211214215637269.png)



