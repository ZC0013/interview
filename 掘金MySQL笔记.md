# 后端存储实践

# MySQL应对高并发问题

MySQL 能承担的并发读写的量是有上限的，当系统的在线用户超过几万到几十万这个量级的时候，单台 MySQL 就很难应付了。

## 一：使用缓存保护MySQL

这种方法对于像电商中的**商品系统、搜索系统**这类与**用户关联不大**的系统，效果特别的好。

因为在这些系统中，每个人看到的内容都是一样的，也就是说，对后端服务来说，每个人的查询请求和返回的数据都是一样的。这种情况下，Redis **缓存的命中率非常高**，近乎于全部的请求都可以命中缓存，相对的，几乎没有多少请求能穿透到 MySQL。

绝大多数互联网系统，都使用 MySQL 加上 Redis 这对儿经典的组合来解决这个问题。Redis 作为 MySQL 的前置缓存，可以替 MySQL 挡住绝大部分查询请求，很大程度上缓解了 MySQL 并发请求的压力。

### Reids简介

Redis 是一个使用内存保存数据的高性能 KV 数据库，它的高性能主要来自于：

1. 简单的数据结构；
2. 使用内存存储数据。

数据库可以分为执行器和存储引擎两部分，Redis 的执行器这一层非常的薄，所以 Redis 只能支持有限的几个 API，几乎没有聚合查询的能力，也不支持 SQL。它的存储引擎也非常简单，直接在内存中用最简单的数据结构来保存数据（Redis 有五种基本数据结构，String, Hash, list, set, zset。

内存是一种易失性存储，所以使用内存保存数据的 Redis 不能保证数据可靠存储。从设计上来说，Redis 牺牲了大部分功能，牺牲了数据可靠性，换取了高性能。但也正是这些特性，使得 Redis 特别适合用来做 MySQL 的前置缓存。

虽然说，Redis 支持将数据持久化到磁盘中，并且还支持主从复制，但你需要知道，Redis 仍然是一个不可靠的存储，它在设计上天然就不保证数据的可靠性，所以一般我们都使用 Redis 做缓存，很少使用它作为唯一的数据存储。(Redis的两种持久化方式：RDB快照 和 AOF日志)

在缓存 MySQL 的一张表的时候，通常直接选用主键来作为 Redis 中的 Key，比如缓存订单表，那就直接用订单表的主键订单号来作为 Redis 中的 key。如果说，Redis 的实例不是给订单表专用的，还需要给订单的 Key 加一个统一的前缀，比如“orders:888888”。Value 用来保存序列化后的整条订单记录，你可以选择可读性比较好的 JSON 作为序列化方式，也可以选择性能更好并且更节省内存的二进制序列化方式，都是可以的。

### MySQL 和 Redis 双写一致性问题

#### 1. Cache Aside模式

![img](md_image/0b9c9cb74f017c632136280a63015931.png)

Cache Aside 模式在更新数据的时候，并不去尝试更新缓存，而是去删除缓存。

订单服务收到更新数据请求之后，先更新数据库，如果更新成功了，再尝试去删除缓存中订单，如果缓存中存在这条订单就删除它，如果不存在就什么都不做，然后返回更新成功。这条更新后的订单数据将在下次被访问的时候加载到缓存中。使用 Cache Aside 模式来更新缓存，可以非常有效地避免并发读写导致的脏数据问题。

#### 2. 缓存延时双删策略

流程：

写请求 -> 删除缓存 -> 更新数据库 -> 休眠一会(1s)，再删除缓存 -> 删除缓存

休眠时间 = 读业务逻辑数据的耗时 + 几百毫秒，目的是为了确保读请求结束，写请求可以删除读请求可能带来的缓存脏数据。

#### 3. Canal 中间件

阿里提供的 canal中间件将 binlog日志采集发送到MQ消息队列中，然后通过ACK 机制确认处理这条更新数据，删除缓存，保证数据一致性。

使用说明：需要开启 mysql 的binlog写入功能。

**上述三种模式的核心点都是要确保删除缓存，因为在并发写的同时，会有别的进程读了还未修改的数据库数据，带来了缓存脏数据。**

### 缓存穿透和缓存雪崩问题

如果我们的缓存命中率比较低，就会出现大量“缓存穿透”的情况。缓存穿透指的是，在读数据的时候，没有命中缓存，请求“穿透”了缓存，直接访问后端数据库的情况。

少量的缓存穿透是正常的，我们需要预防的是，短时间内大量的请求无法命中缓存，请求穿透到数据库，导致数据库繁忙，请求超时。大量的请求超时还会引发更多的重试请求，更多的重试请求让数据库更加繁忙，这样恶性循环导致系统雪崩。

#### 解决系统初上线时缓存穿透问题

**1. 灰度发布**

当系统初始化的时候，比如说系统升级重启或者是缓存刚上线，这个时候缓存是空的，如果大量的请求直接打过来，很容易引发大量缓存穿透导致雪崩。为了避免这种情况，可以采用灰度发布的方式，先接入少量请求，再逐步增加系统的请求数量，直到全部请求都切换完成。

**2 .缓存预热**

如果系统不能采用灰度发布的方式，那就需要在系统启动的时候对缓存进行预热。所谓的缓存预热就是在系统初始化阶段，接收外部请求之前，先把最经常访问的数据填充到缓存里面，这样大量请求打过来的时候，就不会出现大量的缓存穿透了。

## 二：读写分离

# 存在问题

## Hash索引

主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。

检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有Memory等。

MySQL目前有Memory引擎和NDB引擎支持Hash索引。

## full-text全文索引

## R-Tree空间索引

# 索引应用场景

## 哪些情况需要创建索引

1. 主键自动建立唯一索引
2. 频繁作为查询条件的字段
3. 查询中与其他表关联的字段，外键关系建立索引
4. 单键/组合索引的选择问题，高并发下倾向创建组合索引
5. 查询中排序的字段，排序字段通过索引访问大幅提高排序速度
6. 查询中统计或分组字段

## 哪些情况不要创建索引

1. 表记录太少
2. 经常增删改的表
3. 数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）
4. 频繁更新的字段不适合创建索引（会加重IO负担）
5. where条件里用不到的字段不创建索引



# 面试准备问题：

## MVCC

## 事务日志

## MySQL常见瓶颈

- CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候
- IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候
- 服务器硬件的性能瓶颈：top，free，iostat 和 vmstat来查看系统的性能状态

## 性能下降SQL慢 执行时间长 等待时间长 原因分析

- 查询语句写的烂
- 索引失效（单值、复合）
- 关联查询太多join（设计缺陷或不得已的需求）
- 服务器调优及各个参数设置（缓冲、线程数等）
- 并发场景下的 锁 和 并发连接线程数量问题
- 磁盘IO问题

## MySQL常见性能分析手段

在优化MySQL时，通常需要对数据库进行分析，常见的分析手段有**慢查询日志**，**EXPLAIN 分析查询**，**profiling分析**以及**show命令查询系统状态及系统变量**，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。

```mysql
explain select * from t; -- 分析当前查询语句
show processlist ——查看当前SQL执行，包括执行状态、是否锁表等
```

### EXPLAIN 分析查询

**Extra**（包含不适合在其他列中显示但十分重要的额外信息）

1. using filesort: 说明mysql会对数据使用一个外部的索引排序，不是按照表内的索引顺序进行读取。mysql中无法利用索引完成的排序操作称为“文件排序”。常见于order by和group by语句中
2. Using temporary：使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。
3. using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错，如果同时出现using where，表明索引被用来执行索引键值的查找；否则索引被用来读取数据而非执行查找操作
4. Using index condition：即代表本次查询会利用到索引，且会利用到索引下推。
5. using where：使用了where过滤
6. using join buffer：使用了连接缓存
7. impossible where：where子句的值总是false，不能用来获取任何元祖
8. select tables optimized away：在没有group by子句的情况下，基于索引优化操作或对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化
9. distinct：优化distinct操作，在找到第一匹配的元祖后即停止找同样值的动作

### 慢查询日志

MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 `long_query_time` 值的 SQL，则会被记录到慢查询日志中。

- `long_query_time` 的默认值为10，意思是运行10秒以上的语句
- 默认情况下，MySQL数据库没有开启慢查询日志，需要手动设置参数开启

```mysql
# 慢日志相关参数
SHOW VARIABLES LIKE '%slow_query_log%'	-- 查看事故开启
SHOW VARIABLES LIKE 'log-slow-queries'  -- 查看慢日志存放位置

# 修改 my.cnf 用久配置 慢开启日志
slow_query_log = ON
slow_query_log_file = /var/lib/mysql/hostname-slow.log		-- 慢日志存放位置
long_query_time = 3

```

所以MySQL提供了日志分析工具**mysqldumpslow**

得到返回记录集最多的10个SQL

```mysql
mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log
```

得到访问次数最多的10个SQL

```mysql
mysqldumpslow -s c -t 10 /var/lib/mysql/hostname-slow.log
```

得到按照时间排序的前10条里面含有左连接的查询语句

```mysql
mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/hostname-slow.log
```

也可以和管道配合使用

```mysql
mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log | more
```

## 性能优化

**永远小标驱动大表（小的数据集驱动大的数据集）**

**order by关键字优化**

order by子句，尽量使用 Index 方式排序

## MySQL分库分表

### 1. MySQL分表

分表有两种分割方式，一种垂直拆分，另一种水平拆分。主要用于解决单表数据量过大的问题

**垂直拆分**

垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。

**水平拆分(数据分片)**

单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。

水平分割的几种方法：

- 使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。
- 还可根据时间放入不同的表，比如：article_201601，article_201602。
- 按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。
- 根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。

![img](md_image/1734bff39ffffdd1tplv-t2oaga2asx-watermark.awebp)

#### 分表的实际场景

以交友平台用户中心的user表为例，单表数据规模达到千万级别时，你可能会发现使用用户筛选功能查询用户变得非常非常慢，明明查询命中了索引，但是，部分查询还是很慢，这时候，我们就需要考虑拆分这张user表了。

我以最典型的应用场景：用户筛选功能，以查询年龄在18到24岁的100位女性用户为例：

在单表的情况下，我们的SQL是这么写的：

```mysql
SELECT * FROM user WHERE age >= 18 AND age <= 24 AND sex = 0 LIMIT 100
```

但是，拆分user表后，用户记录分散到了多张表，比如，分散到`user_1`，`user_2`，`user_3`这三张表，此时，要查询满足上面条件的用户，我们的查询过程就变成这样：

1. 遍历`user_1`到`user_3`这三张表
2. 分别从三张表找出满足条件的用户，即执行上面的SQL
3. 合并这些用户记录
4. 从合并结果中过滤出前100名用户记录

通过对比，我们会发现**分表后的查询过程跟单表相比，变化是比较大的，这势必导致我们不得不修改代码，如果系统内类似的情况很多，那么，可能引发系统较大规模的业务逻辑改动**，所以，在系统真正出现数据库性能瓶颈前，必须提前规划分表方案，预留时间去做系统改造。

#### 分表的时机

一般的影响数据库查询的因素：

在并发场景下：锁被占用，并发连接线程过多

一般场景：磁盘IO的性能瓶颈

所以优化数据查询的首要问题是，尽量减少数据查询的磁盘IO。

**MySQL为了避免查询时都从磁盘读取查询结果，所以，在磁盘和应用之间加了一层内存，尽可能将磁盘数据加载到内存，那么，下次查询请求访问MySQL时，可以从内存中获取查询结果，避免了过多的磁盘IO的读取**。

![image-20210126223939325.png](md_image/f213f5783aca4968ab50c584893daf97tplv-k3u1fbpfcp-watermark.awebp)

所以尽量保证表单的数据规模不要超过 InnoDB Buffer Pool （包括索引、记录、AHI、数据字典）的大小，超过时就要进行分表。

### 2. MySQL分库

用于解决大规模的并发输入问题

一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。

优点：

- 减少增量数据写入时的锁对查询的影响
- 由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短

但是它无法解决单表数据量太大的问题



### 字节跳动基础架构宣讲，以及字节数据库架构体系

![image-20211214215001286](md_image/image-20211214215001286.png)



![image-20211214215024653](md_image/image-20211214215024653.png)



![image-20211214215241870](md_image/image-20211214215241870.png)



![image-20211214215354328](md_image/image-20211214215354328.png)

云上三板斧：计算、存储、网络

![image-20211214215442363](md_image/image-20211214215442363.png)



![image-20211214215637269](md_image/image-20211214215637269.png)



